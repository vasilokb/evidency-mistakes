**Презентация: "Ловушки очевидных решений в интеграциях: от архитектурных ошибок к осознанным продуктовым решениям"**

---

### Блок 1. Вступление (1–3)

**Слайд 1: Титул**
Вопрос к залу: "Ваша интеграция действительно обслуживает продукт или передает данные?"
Короткое описание цели: показать, что часто самые "простые" решения вылазят в проде или в бизнес.

**Слайд 2: Почему очевидные решения — ловушка?**
Связь интеграций с бизнес-смыслами, тактикой и ролями систем.
Общие типовые мифы: "поднял эндпоинт", "пробросил ид", "они потом разберутся".

**Слайд 3: Симптомы плохих интеграций**
Тематическая миндкарта:

* Сломанный UX
* Потери данных / дублирование
* Невосствия откликов
* Стоимость поддержки > ценности

---

### Блок 2. Ловушки интеграций (4–27)

**Слайд 4–5: Ловушка 1. Жёсткая связанность (tight coupling)**

* **Очевидное решение:** Сервис А синхронно вызывает API сервиса B.
* **Почему оно кажется логичным:** Простой REST-вызов, легко отлаживать, «всё в одном контексте».
* **Продуктовая ошибка:** A зависит от доступности B, даже если B — обслуживает другую часть бизнес-логики.
* **Последствия:** Каскадные сбои, замедление UI, невозможность декомпозиции.
* **Категория взаимодействия:** front-to-back
* **Альтернатива:** Event-Driven, асинхронная доставка события, Pub/Sub
* **Паттерны:** Transactional Outbox, Kafka
* **Пример:** В e-commerce заказ не оформляется, если сервис доставки временно не работает.
* **Визуал:** диаграмма цепочки с синхронным вызовом и вариант с публикацией события

**Слайд 6–7: Ловушка 2. Отсутствие идемпотентности**

* **Очевидное решение:** Повторяем вызов API при таймауте.
* **Почему оно кажется логичным:** Хотим обеспечить доставку команды, а не потерю.
* **Продуктовая ошибка:** Повтор вызывает дублирующую операцию (напр. двойное списание денег).
* **Последствия:** Финансовые ошибки, потери доверия, ручные откаты.
* **Категория взаимодействия:** front-to-back
* **Альтернатива:** Введение idempotency key, хранение состояний обработки
* **Паттерны:** Safe Retry, Idempotency Token
* **Инструменты:** Stripe-style API, Redis-идемпотентность
* **Пример:** Повторная оплата по карте из-за таймаута от API банка
* **Визуал:** последовательная диаграмма с повтором и idempotency key

**Слайд 8–9: Ловушка 3. Синхронные цепочки в асинхронных процессах**

* **Очевидное решение:** Дождаться ответа от всех внешних систем до перехода к следующему шагу.
* **Почему оно кажется логичным:** Гарантия целостности, «хочется всё проверить заранее».
* **Продуктовая ошибка:** Задержки, блокировки, плохой пользовательский опыт.
* **Последствия:** Высокая латентность, timeouts, drop-off в воронке.
* **Категория взаимодействия:** front-to-back
* **Альтернатива:** Saga-паттерн с компенсацией, отложенные действия, разделение этапов
* **Паттерны:** Saga, Eventual Consistency
* **Инструменты:** Spring Boot + Saga Manager, Kafka + Outbox
* **Пример:** Проверка доступности товара и кредитного лимита перед оформлением — задержка 10+ сек
* **Визуал:** диаграмма последовательного вызова → диаграмма событий с компенсацией

**Слайд 16–17: Ловушка 7. Недостаточная наблюдаемость (observability debt)**

* **Очевидное решение:** Логируем в каждом сервисе по-своему — если что, найдём.
* **Почему оно кажется логичным:** «Достаточно логов», «у нас есть stacktrace».
* **Продуктовая ошибка:** Сквозная цепочка вызовов теряется — трудно локализовать причину сбоя.
* **Последствия:** Длительный RCA (root cause analysis), инциденты «вслепую», стресс в поддержке.
* **Категория взаимодействия:** front-to-back и back-to-back
* **Альтернатива:** Distributed Tracing, correlation-id сквозь вызовы
* **Паттерны:** OpenTelemetry, Spans, Tracing Context Propagation
* **Инструменты:** OpenTelemetry, Grafana Tempo, Jaeger
* **Пример:** Клиент жалуется на ошибку при оформлении — инженер тратит 3 часа на разбор 5 логов в 5 сервисах.
* **Визуал:** Скриншот трейсинга → подчёркнутая потеря span → добавление correlation ID

**Слайд 18–19: Ловушка 8. Нарушение границ ответственности**

* **Очевидное решение:** Система B принимает решение за A, потому что «она ближе к данным».
* **Почему оно кажется логичным:** Меньше дублирования логики, «оптимизация».
* **Продуктовая ошибка:** Решение принимается не в том контексте, где видна бизнес-смысловая картина.
* **Последствия:** Размытые границы, баги при изменении бизнес-правил, конфликтные UX-сценарии.
* **Категория взаимодействия:** front-to-back + back-to-back
* **Альтернатива:** Чёткие границы доменов, contract-first взаимодействие
* **Паттерны:** Bounded Context, Domain Responsibility Mapping
* **Инструменты:** Архитектурная карта взаимодействий, DSL
* **Пример:** Сервис доставки сам решает, отменить ли заказ, хотя отмена — право клиента в UI.
* **Визуал:** Схема: зона ответственности систем → баг из-за инверсии контроля

**Слайд 20–21: Ловушка 9. Интеграция без тестов под нагрузкой и отказов**

* **Очевидное решение:** «Если работает на dev/stage — должно работать в проде».
* **Почему оно кажется логичным:** Экономия времени, нет отдельной среды или нагрузки.
* **Продуктовая ошибка:** В боевых условиях система ломается — и никто не знал, что так будет.
* **Последствия:** Инциденты после релизов, неустойчивое поведение, невозможность предсказать деградации.
* **Категория взаимодействия:** front-to-back и back-to-back
* **Альтернатива:** Chaos Engineering, тестирование через fault injection
* **Паттерны:** Failure Injection Testing, SLA Monitoring
* **Инструменты:** Chaos Toolkit, Gatling, k6, Toxiproxy
* **Пример:** При росте заказов Black Friday очередь заказов зависает, потому что никто не проверил поведение при high-throughput.
* **Визуал:** график throughput до/после тестов + диаграмма с точками отказа

**Слайд 22–23: Ловушка 10. Антипаттерн: прямые запросы к БД другой системы**

* **Очевидное решение:** Получить данные напрямую из БД соседнего сервиса — быстрее и «без лишней бюрократии».
* **Почему оно кажется логичным:** «У нас один кластер», «документация устарела, а в БД всё видно».
* **Продуктовая ошибка:** Нарушается граница контекста, слабая связанность превращается в жёсткую.
* **Последствия:** Хрупкость, невозможность миграции, постоянные баги при смене схемы.
* **Категория взаимодействия:** front-to-back
* **Альтернатива:** Предоставление API или read-моделей через очередь
* **Паттерны:** CQRS, Event-carried State Transfer, API Gateway
* **Инструменты:** Kafka, Materialized Views, GraphQL federation
* **Пример:** UI-сервис напрямую запрашивает таблицу клиентских адресов у CRM, а она переехала — всё ломается.
* **Визуал:** Схема: стрелка в БД → замена на очередь + read model

**Слайд 24–25: Ловушка 11. Избыточная декомпозиция (микросервисы ради микросервисов)**

* **Очевидное решение:** Декомпозировать всё на мельчайшие сервисы: «одна таблица — один сервис».
* **Почему оно кажется логичным:** Следование моде, кажущийся контроль и изоляция.
* **Продуктовая ошибка:** Рост сложности взаимодействия, задержки на вызовах, размывание бизнес-логики.
* **Последствия:** Chatty API, высокая стоимость поддержки, рост ошибок в коммуникации
* **Категория взаимодействия:** back-to-back
* **Альтернатива:** Укрупнение по бизнес-функциям, минимизация внешнего общения
* **Паттерны:** Component Enclosure, Aggregate Service Boundary
* **Инструменты:** DDD map, latency budget, API complexity heatmap
* **Пример:** Amazon Prime Video отказались от микросервисов в обработке видео и снизили издержки в 90%.
* **Визуал:** Таблица: количество сервисов vs SLA, latency, количество багов

**Слайд 26–27: Ловушка 12. API, неудобный для продукта (анти-UX API)**

* **Очевидное решение:** Каждый ресурс — отдельный вызов API.
* **Почему оно кажется логичным:** «REST по стандарту», «меньше логики на бэке».
* **Продуктовая ошибка:** Пользовательский путь раздроблен, медленно собираются данные, плохой UX.
* **Последствия:** Низкая конверсия, недовольство пользователей, рост количества запросов
* **Категория взаимодействия:** front-to-back
* **Альтернатива:** API, ориентированные на сценарии, GraphQL, агрегированные ресурсы
* **Паттерны:** Backend for Frontend (BFF), GraphQL Gateway
* **Инструменты:** Apollo, GraphQL federation, gRPC with composite handlers
* **Пример:** Slack перешёл на GraphQL, чтобы сократить число запросов и ускорить загрузку.
* **Визуал:** Сравнение: REST (5 вызовов) → GraphQL (1 вызов), latency график

**Слайд 28: Мэппинг ловушек на паттерны и тип взаимодействия**

| Ловушка № | Название                         | Тип взаимодействия | Паттерны / Подходы                          | Инструменты                        |
| --------- | -------------------------------- | ------------------ | ------------------------------------------- | ---------------------------------- |
| 1         | Жёсткая связанность              | front-to-back      | Pub/Sub, Transactional Outbox               | Kafka, Debezium                    |
| 2         | Нет идемпотентности              | front-to-back      | Idempotency Key, Safe Retry                 | Redis, Stripe-style API            |
| 3         | Синхрон в асинхроне              | front-to-back      | Saga, Eventual Consistency                  | Kafka, Spring Saga                 |
| 4         | Нет backpressure                 | back-to-back       | Bulkhead, Rate Limiting                     | Resilience4j, Kafka                |
| 5         | Нет контракта / версионирования  | front-to-back      | Consumer-Driven Contracts, OpenAPI          | Pact, Spring Contract, Schema Reg. |
| 6         | Распределённые транзакции        | back-to-back       | Transactional Outbox, Saga                  | Kafka, Debezium                    |
| 7         | Отсутствие наблюдаемости         | f2b + b2b          | Distributed Tracing, Correlation ID         | OpenTelemetry, Grafana Tempo       |
| 8         | Нарушение границ ответственности | f2b + b2b          | Bounded Context, Domain Mapping             | DSL, Арх. модель взаимодействий    |
| 9         | Нет тестов под отказ и нагрузку  | f2b + b2b          | Chaos Engineering, Failure Injection        | Chaos Toolkit, k6, Gatling         |
| 10        | Прямой доступ к чужой БД         | front-to-back      | CQRS, Event-carried State Transfer          | Kafka, Materialized Views          |
| 11        | Избыточная декомпозиция          | back-to-back       | Component Enclosure, API Complexity Control | DDD map, latency map               |
| 12        | Анти-UX API                      | front-to-back      | GraphQL, BFF, Composite APIs                | Apollo, GraphQL Gateway, gRPC      |

**Слайд 29: Продуктово-архитектурный чек-лист**

Чтобы оценить устойчивость интеграций, задайте:

1. Может ли сценарий работать при недоступности одной из систем?
2. Где принимается бизнес-решение — в правильной ли системе?
3. Есть ли контракты взаимодействия? Есть ли их тесты?
4. Есть ли наблюдаемость сквозных взаимодействий?
5. Учитывали ли вы пиковые нагрузки и сценарии отказа?
6. Каковы границы ответственности сервисов?
7. Совпадают ли технические взаимодействия с продуктовой логикой?

**Слайд 30: Заключение**

* Интеграция — не про вызовы, а про ответственность
* Очевидные решения — часто мина замедленного действия
* Устойчивость = архитектурные паттерны + продуктовая ясность
* Роль аналитика: проектировать взаимодействие как бизнес-интерфейс, а не просто API

**Слайд 31: Q\&A + визуальный рекап**

* Слайд с иконками 12 ловушек и краткими названиями — для запоминания и вопросов


